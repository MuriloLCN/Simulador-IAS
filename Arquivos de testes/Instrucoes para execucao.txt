Nesse arquivo constam as descrições das memórias para se realizar simulações com os arquivos-teste feitos, bem como
observações para a simulação com arquivos externos.

Deve-se garantir que para todo arquivo que será simulado ele atenda aos seguintes requisitos:

1. O arquivo deve, obrigatoriamente, possuir uma seção declarando a quantidade de ciclos de clock para as instruções 
logo em seu início, um exemplo está a seguir:

/*
loadm:11
loadmm:1
stor:2
load:3
load-m:4
load|m:5
load-|m:6 
jump:7
jump+:8
add:9
add|:10
sub:11
sub|:12
mul:13
div:14
lsh:15
rsh:16
storm:17
*/

2. Os arquivos-teste providenciados devem ter as suas variáveis respeitadas de acordo com as tabelas abaixo, incluindo valores de memória que representam
espaços em branco [e.g, a ordenação pode ser feito com um vetor de qualquer tamanho, porém alterações nele necessitariam re-calcular todos
os endereços de modificação e de jumps, devido a natureza das instruções IAS].

3. Os arquivos-teste devem ser executados com o PC inicial conforme indicado após às suas respectivas tabelas
Exemplo:
Windows: [programa].exe -p collatz.ias -i 21
Linux: ./[programa] -p collatz.ias -i 21

4. Para programas de teste externos, devem ser observados alguns detalhes:

4.1: Deve-se garantir que instruções que são diferenciadas por seus sufixos (e.g, STOR e JUMP/JUMP+) não possuam espaços após sua escrita.

4.2: Deve-se garantir que as intruções estejam escritas corretamente de modo igual aos arquivos de teste disponibilizados.

4.3: Deve-se garantir que o programa, de maneira obrigatória, atinja uma instrução EXIT ao seu término, caso contrário, a simulação continuará e
não será gerado um arquivo de saída.

4.4: Como instruções não reconhecidas pelo parser de entrada são mapeadas para instruções "NENHUMA" (i.e, bolhas), ao início da simulação, deve-se
observar se não foram emitidos nenhum aviso de "Instrução não reconhecida" no terminal. Caso o programa não reconheça alguma instrução por
erro do(a) programador(a) em seguir os itens acima, o programa provavelmente não terá o comportamento desejado. 

4.4.1: Por decisão de projeto, o simulador não impede a execução de um programa caso exista algum erro de sintaxe/instrução não reconhecida, porém
há uma flag opcional disponibilizada na main() que pode ser alterada e que permite que a execução não seja iniciada caso hajam erros desse tipo.

4.4.2: Note que ao se deixar espaços após instruções que são diferenciadas por seus sufixos pode levar a instrução errada a ser decodificada, e
esse erro é silencioso.

----------- Disposições de memórias dos arquivos de testes --------

Conjectura de collatz
Ordem da memória
Endereço | Variável | Valor que deve estar no começo
00       | i        | qualquer valor
01       | inicio_v | 6
02       | um       | 1
03       | dois     | 2
04       | tres     | 3
05       | quatorze | 14
06       | v_inicial| Valor que se quer usar como início da sequência (entrada)
07-20    | v1-v14   | Valores que serão calculados pelo algoritmo (saída)
21+      | instruções...
PC Inicial = 21

-------------------------------------------------------------------

Ordenação por seleção

Ordem da memória
Endereço | Variável | Valor que deve estar no começo
00       | i        | qualquer valor
01       | j        | qualquer valor
02       | min_idx  | qualquer valor
03       | um       | 1
04       | init_vet | 7
05       | temp     | qualquer valor
06       | tamanho  | O número de elementos do vetor
07-24    | vetor    | Elementos do vetor
25+      | Instruções...
PC Inicial = 25

-------------------------------------------------------------------

Multiplicação de Matrizes
Ordem da memória
Endereço | Variável | Valor que deve estar no começo
00       | A(m)     | número de linhas da matriz A
01       | A(n)     | número de colunas da matriz A
02       | B(m)     | número de linhas da matriz B
03       | B(n)     | número de colunas da matriz B
04       | q = 18   | onde A começa na memória
05       | t        | onde B começa na memória -> t = q + (A(m) x A(n))
06       | u        | onde C (Matriz resultante do produto de AxB) começa na memória -> u = t + (B(m) x B(n))
07       | loop i   | 
08       | loop j   |
09       | loop k   |
10       | temp     | qualquer valor
11       | D1       | D1 a D5, variáveis para as operações trabalharem livremente
12       | D2
13       | D3
14       | D4
15       | D5
16       | V0       | variável que contém o valor 0
17       | V1       | variável que contém o valor 1
A[i][j] = q + A(m) x i + j
B[i][j] = t + A(n) x i + j
C[i][j] = u + A(n) x i + j
PC Inicial = 

-------------------------------------------------------------------

Fatorial
Ordem da memória
Endereço | Variável | Valor que deve estar no começo
00       | i        | valor 1, usado para o decremento
01       | n        | valor a ser calculado o fatorial (vai sendo decrementado cada iteração)
02       | resultado| qualquer valor. Guarda o resultado parcial do cálculo do fatorial. No fim da execução, tem o resultado final
03+      | Instruções...
PC Inicial = 3

-------------------------------------------------------------------

Busca Binária
Ordem da memória
Endereço | Variável | Valor que deve estar no começo
00       | flag     | valor 1. Se o algoritmo não encontrar o número procurado, a flag assume o valor 0
01       | mid      | qualquer valor. Índice do meio, calculado para pegar o elemento central do vetor
02       | temp1    | qualquer valor
03       | temp2    | qualquer valor
04       | esq      | posição na memória do primeiro elemento do vetor
05       | dir      | posição na memória do último elemento do vetor
06       | n        | número a ser buscado
07       | vetor[0] | qualquer número, desde que o vetor seja ordenado
08       | vetor[1] | qualquer número, desde que o vetor seja ordenado
09       | vetor[2] | qualquer número, desde que o vetor seja ordenado
10       | vetor[3] | qualquer número, desde que o vetor seja ordenado
11       | vetor[4] | qualquer número, desde que o vetor seja ordenado
12       | vetor[5] | qualquer número, desde que o vetor seja ordenado
13       | vetor[6] | qualquer número, desde que o vetor seja ordenado
14       | vetor[7] | qualquer número, desde que o vetor seja ordenado
15       | vetor[8] | qualquer número, desde que o vetor seja ordenado
16       | vetor[9] | qualquer número, desde que o vetor seja ordenado
17       | vetor[10]| qualquer número, desde que o vetor seja ordenado
18       | vetor[11]| qualquer número, desde que o vetor seja ordenado
19+      | Instruções...
PC Inicial = 19